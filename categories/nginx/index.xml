<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nginx on 太阳可以是蓝色</title>
    <link>https://blog.mletter.cn/categories/nginx/</link>
    <description>Recent content in Nginx on 太阳可以是蓝色</description>
    <image>
      <title>太阳可以是蓝色</title>
      <url>https://blog.mletter.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.mletter.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 20 Mar 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.mletter.cn/categories/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nginx简单的常规优化</title>
      <link>https://blog.mletter.cn/tech/nginx/nginx-optimization/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://blog.mletter.cn/tech/nginx/nginx-optimization/</guid>
      <description>主要讲解nginx具体有那些优化项</description>
      <content:encoded><![CDATA[<h2 id="配置nginx的work_process">配置nginx的work_process</h2>
<p>查看当前服务的CPU核心数量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>root@containerd-master1 ~<span class="o">]</span><span class="c1"># grep processor /proc/cpuinfo | wc -l</span>
</span></span><span class="line"><span class="cl"><span class="m">8</span>
</span></span></code></pre></div><p>如果你需要修改更多的工作进程,请修改配置文件中的<code>work_process</code>字段</p>
<ul>
<li><code>auto</code>: 根据系统的CPU自动的设置工作进程数量</li>
</ul>
<pre tabindex="0"><code class="language-conf" data-lang="conf">worker_processes  1; # 可选值 auto
</code></pre><h2 id="配置work_connections">配置work_connections</h2>
<p>该参数表示每个工作进程最大处理的连接数,<code>CentOS</code>默认连接数为1024,连接数是可以修改的。
如果需要修改<code>ulimit</code>参数,请修改配置文件<code>/etc/security/limits.conf</code></p>
<ul>
<li>noproc 是代表最大进程数</li>
<li>nofile 是代表最大文件打开数</li>
</ul>
<blockquote>
<p>本次修改仅仅以Rocky Linux和CentOS为例,不同的系统修改方法可能有所差异.</p></blockquote>
<pre tabindex="0"><code class="language-conf" data-lang="conf">* soft nofile 65535
* hard nofile 65535
</code></pre><p>配置nginx当中的<code>work_connections</code></p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">events {
    worker_connections  65535;
    use epoll;
}
</code></pre><blockquote>
<p>简单的提一嘴ulimit的作用: 当进程打开的文件数目超过此限制时，该进程就会退出。</p></blockquote>
<h2 id="启用gzip压缩">启用gzip压缩</h2>
<p>nginx使用 gzip 进行文件压缩和解压缩,您可以节省带宽并在连接缓慢时提高网站的加载时间。</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">server {
    gzip on;  # 开启gzip
    gzip_vary on;
    gzip_min_length 10240;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml;
    gzip_disable &#34;MSIE [1-6]\.&#34;;
}
</code></pre><h2 id="限制nginx连接的超时">限制nginx连接的超时</h2>
<p>主要是为了减少打开和关闭连接时的处理器和网络开销</p>
<ul>
<li><code>client_body_timeout</code>: 该指令设置请求体（request body）的读超时时间。仅当在一次readstep中，没有得到请求体，就会设为超时。超时后，nginx返回HTTP状态码408</li>
<li><code>client_header_timeout</code>: 指定等待client发送一个请求头的超时时间（例如:GET / HTTP/1.1)仅当在一次read中，没有收到请求头，才会被记录为超时</li>
<li><code>keepalive_timeout</code>: 指定了与<code>client</code>的<code>keep-alive</code>连接超时时间,超过这个时间后,服务器会关关闭连接。</li>
<li><code>send_timeout</code>: 指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。</li>
</ul>
<pre tabindex="0"><code class="language-conf" data-lang="conf">http
{
    client_body_timeout 12;
    client_header_timeout 12;
    keepalive_timeout 15;
    send_timeout 10;
}
</code></pre><h2 id="调整缓冲区大小">调整缓冲区大小</h2>
<p>调整nginx缓冲区以优化服务器性能。如果缓冲区大小太小，那么nginx将写入一个临时文件，导致大量 I/O 操作不断运行。</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">http
{
    client_body_buffer_size 10K;
    client_header_buffer_size 1k;
    client_max_body_size 8m;
    large_client_header_buffers 4 4k;
}
</code></pre><h2 id="启用日志访问缓冲区">启用日志访问缓冲区</h2>
<p>日志很重要，因为它们有助于解决问题。完全禁用日志不是一个好的做法。在这种情况下，您可以启用访问日志缓冲。这将允许nginx缓冲一系列日志并将它们一次写入日志文件，而不是对每个请求应用不同的日志操作。在nginx配置文件中添加以下行以允许访问日志缓冲</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;
                      &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;
                      &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;
    # 开启日志缓冲设置
    access_log  logs/access.log main buffer=32k flush=1m;
}
</code></pre><h2 id="调整静态文件缓存">调整静态文件缓存</h2>
<pre tabindex="0"><code class="language-conf" data-lang="conf"># 静态文件缓存内容
location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
  expires 90d;
}
</code></pre>]]></content:encoded>
    </item>
  </channel>
</rss>
