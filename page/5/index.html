<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.138.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>太阳可以是蓝色</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="iren."><link rel=canonical href=https://blog.mletter.cn/><link crossorigin=anonymous href=/assets/css/stylesheet.54398d0fb317133a824d0a4034cf0879e64c7449a21217c62f4c262009100d8f.css integrity="sha256-VDmND7MXEzqCTQpANM8IeeZMdEmiEhfGL0wmIAkQDY8=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.mletter.cn/index.xml><link rel=alternate type=application/json href=https://blog.mletter.cn/index.json><link rel=alternate hreflang=zh href=https://blog.mletter.cn/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=/view-image.min.js></script><script>window.ViewImage&&ViewImage.init("img")</script><style>:root{--sys-font-family:-apple-system, "PingFang SC", Georgia, 'Nimbus Roman No9 L', 'Hiragino Sans GB', 'Noto Serif SC', 'Microsoft Yahei', 'WenQuanYi Micro Hei', 'ST Heiti', sans-serif;--code-font-family:"JetBrains Mono", Menlo, Monaco, Consolas, "Courier New";--article-font-family:-apple-system, "PingFang SC", var(--base-font-family)}</style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta property="og:url" content="https://blog.mletter.cn/"><meta property="og:site_name" content="太阳可以是蓝色"><meta property="og:title" content="太阳可以是蓝色"><meta property="og:description" content="ExampleSite description"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://blog.mletter.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.mletter.cn/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="太阳可以是蓝色"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"太阳可以是蓝色","url":"https://blog.mletter.cn/","description":"ExampleSite description","logo":"https://blog.mletter.cn/%3Clink%20/%20abs%20url%3E","sameAs":["https://space.bilibili.com/477276392","beilanzhisen@163.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.mletter.cn/ accesskey=h title="太阳可以是蓝色 (Alt + H)">太阳可以是蓝色</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.mletter.cn/ title=主页><span class=active>主页</span></a></li><li><a href=https://blog.mletter.cn/posts/ title=文章><span>文章</span></a></li><li><a href=https://blog.mletter.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.mletter.cn/friends/ title=友联><span>友联</span></a></li><li><a href=https://blog.mletter.cn/about title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://img14.360buyimg.com/ddimg/jfs/t1/164569/9/40677/14419/65bc6e4cFa1d8c0c3/5ccf7e6caadc9b83.jpg alt></figure><header class=entry-header><h2 class=entry-hint-parent>利用Kubeadm进行多Master高可用部署</h2></header><div class=entry-content><p>利用Kubeadm创建高可用集群 使用具有堆叠的控制平面节点。这种方法所需基础设施较少。etcd 成员和控制平面节点位于同一位置。 使用外部 etcd 集群。这种方法所需基础设施较多。控制平面的节点和 etcd 成员是分开的。 在下一步之前，你应该仔细考虑哪种方法更好地满足你的应用程序和环境的需求。 高可用拓扑选项 讲述了每种方法的优缺点。 如何安装Kubectl和Kubeadm 如何安装外部的Etcd集群 参与主机列表 IP CPU 内存 硬盘 角色 10.1.6.48 8 16 100 control-plane1 10.1.6.24 8 16 100 control-plane2 10.1.6.45 8 16 100 control-plane3 10.1.6.46 8 16 100 work1 10.1.6.43 8 16 100 work2 10.1.6.47 8 16 100 work3 10.1.6.213 4 4 20 HA+KP1 10.1.6.214 4 4 20 HA+KP2 10.1.6.215 Load_Balancer_IP 10.1.6.51 8 16 100 Etcd1 10.1.6.52 8 16 100 Etcd2 10.1.6.53 8 16 100 Etcd3 为Kube-apiserver创建负载均衡器 Keepalived 提供 VRRP 实现，并允许您配置 Linux 机器使负载均衡，预防单点故障。HAProxy 提供可靠、高性能的负载均衡，能与 Keepalived 完美配合。
...</p></div><footer class=entry-footer><span title='2022-12-29 00:00:00 +0000 UTC'>十二月 29, 2022</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to 利用Kubeadm进行多Master高可用部署" href=https://blog.mletter.cn/tech/kubernetes/install-kubernetes-ha/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://img14.360buyimg.com/ddimg/jfs/t1/164569/9/40677/14419/65bc6e4cFa1d8c0c3/5ccf7e6caadc9b83.jpg alt></figure><header class=entry-header><h2 class=entry-hint-parent>Kubernetes低版本中内存泄漏问题</h2></header><div class=entry-content><p>Kubernetes中Cgroup泄漏问题 Cgorup文档: https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt
绝大多数的kubernetes集群都有这个隐患。只不过一般情况下，泄漏得比较慢，还没有表现出来而已。
一个pod可能泄漏两个memory cgroup数量配额。即使pod百分之百发生泄漏， 那也需要一个节点销毁过三万多个pod之后，才会造成后续pod创建失败。
一旦表现出来，这个节点就彻底不可用了，必须重启才能恢复。
故障表现 该内容的故障信息已经提交给Github: https://github.com/kubernetes/kubernetes/issues/112940 我在服务器中更新Pod出现如下错误 cannot allocate memory
unable to ensure pod container exists: failed to create container for [kubepods burstable podd5dafc96-2bcd-40db-90fd-c75758746a7a] : mkdir /sys/fs/cgroup/memory/kubepods/burstable/podd5dafc96-2bcd-40db-90fd-c75758746a7a: cannot allocate memory 使用dmesg查看系统日志的错误内容信息
SLUB: Unable to allocate memory on node -1 服务器配置信息 操作系统: CentOS Linux release 7.9.2009 (Core) 系统内核: 3.10.0-1160.el7.x86_64 Kubernetes: 1.17.9 dockerVersion: 20.10.7 问题原因1 Kubernetes在1.9版本开启了对kmem的支持,因此 1.9以后的所有版本都有该问题，但必须搭配3.x内核的机器才会出问题。一旦出现会导致新 pod 无法创建，已有 pod不受影响，但pod 漂移到有问题的节点就会失败，直接影响业务稳定性。因为是内存泄露，直接重启机器可以暂时解决，但还会再次出现。 cgroup的kmem account特性在3.x 内核上有内存泄露问题，如果开启了kmem account特性会导致可分配内存越来越少，直到无法创建新 pod 或节点异常。
kmem account 是cgroup 的一个扩展，全称CONFIG_MEMCG_KMEM，属于机器默认配置，本身没啥问题，只是该特性在 3.10 的内核上存在漏洞有内存泄露问题，4.x的内核修复了这个问题。 因为 kmem account 是 cgroup 的扩展能力，因此runc、docker、k8s 层面也进行了该功能的支持，即默认都打开了kmem 属性。 因为3.10 的内核已经明确提示 kmem 是实验性质，我们仍然使用该特性，所以这其实不算内核的问题，是 k8s 兼容问题。 问题原因2 memcg是 Linux 内核中用于管理 cgroup 内存的模块，整个生命周期应该是跟随 cgroup 的，但是在低版本内核中(已知3.10)，一旦给某个 memory cgroup 开启 kmem accounting 中的 memory.kmem.limit_in_bytes 就可能会导致不能彻底删除 memcg 和对应的 cssid，也就是说应用即使已经删除了 cgroup (/sys/fs/cgroup/memory 下对应的 cgroup 目录已经删除), 但在内核中没有释放 cssid，导致内核认为的 cgroup 的数量实际数量不一致，我们也无法得知内核认为的 cgroup 数量是多少。 这个问题可能会导致创建容器失败，因为创建容器为其需要创建 cgroup 来做隔离，而低版本内核有个限制：允许创建的 cgroup 最大数量写死为 65535，如果节点上经常创建和销毁大量容器导致创建很多 cgroup，删除容器但没有彻底删除 cgroup 造成泄露(真实数量我们无法得知)，到达 65535 后再创建容器就会报创建 cgroup 失败并报错 no space left on device，使用 kubernetes 最直观的感受就是 pod 创建之后无法启动成功。
...</p></div><footer class=entry-footer><span title='2022-10-08 00:00:00 +0000 UTC'>十月 8, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Kubernetes低版本中内存泄漏问题" href=https://blog.mletter.cn/tech/kubernetes/memory-leakage-analysis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ansible-任务控制</h2></header><div class=entry-content><p>Ansible-with_items 通过with_items进行循环 语法
{{ item }}: 为读取with_items的固定写法 with_items: 是一个列表,下面可以有多个不同的内容 - hosts: test remote_user: root gather_facts: false vars_files: ./public_vars.yaml tasks: - name: Services Http start service: name={{ item }} state=started with_items: - httpd - firewalld 普通写法 - hosts: test remote_user: root gather_facts: false vars_files: ./public_vars.yaml tasks: - name: Set authorized_key in dest hosts authorized_key: user: root key: "{{ lookup('file', '/root/.ssh/id_rsa.pub') }}" register: result_auth_info tags: authorized_key_hosts - name: Install httpd yum: name="httpd" state=present - name: Services Http start service: name={{ item }} state=started with_items: - httpd - firewalld 使用变量的循环写法 - hosts: test remote_user: root gather_facts: true tasks: - name: Install httpd yum: name={{ packages }} state=present vars: packages: - httpd - pcre-devel 使用变量字典循环方式批量创建用户 - hosts: test remote_user: root gather_facts: false vars_files: ./public_vars.yaml tasks: - name: Add Users user: name={{ item.name }} groups={{ item.groups }} state=present with_items: - { name: "alex",groups: "test"} - { name: "alex1",groups: "test"} 使用变量字典循环拷贝文件 - hosts: test remote_user: root gather_facts: false tasks: - name: Add Users copy: src: '{{ item.src }}' dest: '{{ item.dest }}' mode: '{{ item.mode }}' with_items: - { src: "./1.txt", dest: "/tmp", mode: 0644} - { src: "./2.txt", dest: "/tmp", mode: 0644} Ansible-Handlers 通过notify进行监控->通过handlers触发 关于Handler的一些小注意事项
...</p></div><footer class=entry-footer><span title='2022-08-29 00:00:00 +0000 UTC'>八月 29, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Ansible-任务控制" href=https://blog.mletter.cn/tech/ansible/ansible-task-controller/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ansible变量相关内容</h2></header><div class=entry-content><p>Ansible怎么定义变量 通过playbook中的play进行变量的定义 通过inventory主机清单进行变量定义 通过执行playbook的时候增加-e选项进行定义 通过Playbook中的vars定义变量 在Playbook中通过写入vars语法定义变量 通过{{变量名}}进行引用! - hosts: test remote_user: root vars: - httpd_package: httpd tasks: - name: Install DepencyEnvorment yum: name: {{httpd_package}} state: present update_cache: yes 通过定义变量文件进行使用 定义一个名字为public_vars.yaml的变量配置文件 depence: ['openssl-devel','pcre-devel','zlib-devel'] 注意: 当你引用了变量文件中的变量,请在读取变量的时候增加双引号""
- hosts: test remote_user: root vars_files: - ./public_vars.yaml - ./public_vars2.yaml # 如果是多个变量的话 tasks: - name: "Install De" yum: name: "{{depence}}" # 通过双引号去引入变量内容,不然会报错 state: present update_cache: no 通过编辑inventory主机清单进定义 这种方法一般用的很少 [test] 10.1.6.205 [test:vars] file_name=group_sys 官方推荐的方法: 在项目目录中创建两个变量目录host_vars和group_vars
...</p></div><footer class=entry-footer><span title='2022-08-15 00:00:00 +0000 UTC'>八月 15, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Ansible变量相关内容" href=https://blog.mletter.cn/tech/ansible/ansible-varbles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL小小优化思路简单版本</h2></header><div class=entry-content><p>MySQL性能优化-优化思路 大概的优化思路分为以下几个内容
硬件层面优化 系统层面优化 MySQL版本选择优化 MySQL三层结构及参数优化 MySQL开发规范 MySQL的索引优化 MySQL的事务以及锁优化 MySQL架构优化 MySQL安全优化 PS: 优化是有风险的,如果你要优化就要变更。
硬件层面优化 这个地方就略过了就是一些加大硬件配置的需求.
系统层面优化 id: 空闲状态,如果数值越大,表示空闲状态越多。如果可能达到0的情况下,表示当前CPU的核心处于满负荷状态。 us: 表示当前CPU核心数量的使用率。 sy: 表示CPU与内核交互的频率,内核与CPU处理请求的占用,如果此参数高,表示内核很忙。 wa: CPU从内存中刷数据到硬盘中的占用,可能会出现I/O的问题。 [root@mysql-master ~]# top top - 15:05:11 up 35 days, 5:54, 2 users, load average: 0.00, 0.01, 0.05 Tasks: 225 total, 2 running, 223 sleeping, 0 stopped, 0 zombie %Cpu0 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu1 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu2 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu3 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu4 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu5 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu6 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st %Cpu7 : 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 24522416 total, 14931524 free, 3675344 used, 5915548 buff/cache KiB Swap: 12386300 total, 12386300 free, 0 used. 20450988 avail Mem 通过 top -Hp 10380 指定占用高的进程,可以看到具体是那些线程占用过高
...</p></div><footer class=entry-footer><span title='2022-07-20 00:00:00 +0000 UTC'>七月 20, 2022</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to MySQL小小优化思路简单版本" href=https://blog.mletter.cn/tech/mysql/mysql-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker常见的几个问题处理</h2></header><div class=entry-content><p>Docker迁移存储目录 问题起因 由于公司最开始的服务器在/var/lib/docker没有挂载存储,容量只有40G,导致服务器磁盘用满。现将原有的Docker目录数据进行迁移。
请各位Kubernetes用户不要操作,因为容器编排不支持!
# 启动容器发现如下报错 ERROR：cannot create temporary directory! 方法一: 软连接方式 # 1.停止docker服务 systemctl stop docker # 2.开始迁移目录 mv /var/lib/docker /data/ # 使用cp命令也可以 cp -arv /var/lib/docker /data/docker # 3.添加软链接 ln -s /data/docker /var/lib/docker # 4.启动docker服务 systemctl start docker 方法二: 修改docker配置文件 注意: 这是一个旧版本docker修改存储目录的方式.
vim /etc/docker/daemon.json { "graph": [ "/data/docker/" ] # 更改docker镜像的存储目录 } 新版本修改存储目录方式
# 请找到你的docker.service存放位置 vim /usr/lib/systemd/system/docker.service 通过加入--data-root=/data/docker进行修改默认的数据存储位置
[Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd --data-root=/data/docker ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 修改完成之后重启docker
...</p></div><footer class=entry-footer><span title='2022-07-14 00:00:00 +0000 UTC'>七月 14, 2022</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Docker常见的几个问题处理" href=https://blog.mletter.cn/tech/docker/docker-frequently-asked-questions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Playbook的一些简单使用</h2></header><div class=entry-content><p>playbook是由一个或多个"play"组成的列表 playbook的主要功能在于将预定义的一组主机，装扮成事先通过ansible中的task定义好的角色。 Task实际是调用ansible的一个module，将多个play组织在一个playbook中， 即可以让它们联合起来，按事先编排的机制执行预定义的动作 Playbook采用YAML语言编写 --- - hosts: test # 指定主机列表 remote_user: root # 远程操作以什么身份执行 tasks: - name: Install Redis # 提示字段,表示当前处于什么进度 command: install redis # 当前执行的具体命令操作 1.0 PlayBook核心元素 Hosts：playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务,hosts用于指定要执行指定任务的主机，须事先定义在主机清单中.详细请看 remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务.此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户. varniables: 内置变量或自定义变量在playbook中调用 Templates模板 : 可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers和notify: 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags: 指定某条任务执行，用于选择运行playbook中的部分代码. ansible-playbook -C hello.yaml -C 选项检查剧本是否成功,并不实际执行 1.0.1 忽略错误信息 也可以使用ignore_errors来忽略错误信息
tasks: - name: run this shell: /usr/bin/ls || /bin/true ignore_errors: True 1.0.2 常用选项 --check: 只检测可能会发生的改变,但是不会执行 --list-hosts: 列出运行任务的主机 --limit: 主机列表,只针对主机列表中的主机执行 -v: 显示过程 --list-tasks: 查看任务列表 ansible-playbook hello.yaml --check ansible-playbook hello.yaml --list-hosts ansible-playbook hello.yaml --limit 10.1.6.111 2.0 Handlers和notify 由于playbook执行会有次序问题,所以当出现次序问题的时候,可以使用handlers结合notify
...</p></div><footer class=entry-footer><span title='2022-04-01 00:00:00 +0000 UTC'>四月 1, 2022</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Playbook的一些简单使用" href=https://blog.mletter.cn/tech/ansible/playbook/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx简单的常规优化</h2></header><div class=entry-content><p>配置nginx的work_process 查看当前服务的CPU核心数量
[root@containerd-master1 ~]# grep processor /proc/cpuinfo | wc -l 8 如果你需要修改更多的工作进程,请修改配置文件中的work_process字段
auto: 根据系统的CPU自动的设置工作进程数量 worker_processes 1; # 可选值 auto 配置work_connections 该参数表示每个工作进程最大处理的连接数,CentOS默认连接数为1024,连接数是可以修改的。 如果需要修改ulimit参数,请修改配置文件/etc/security/limits.conf
noproc 是代表最大进程数 nofile 是代表最大文件打开数 本次修改仅仅以Rocky Linux和CentOS为例,不同的系统修改方法可能有所差异.
* soft nofile 65535 * hard nofile 65535 配置nginx当中的work_connections
events { worker_connections 65535; use epoll; } 简单的提一嘴ulimit的作用: 当进程打开的文件数目超过此限制时，该进程就会退出。
启用gzip压缩 nginx使用 gzip 进行文件压缩和解压缩,您可以节省带宽并在连接缓慢时提高网站的加载时间。
server { gzip on; # 开启gzip gzip_vary on; gzip_min_length 10240; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml; gzip_disable "MSIE [1-6]\."; } 限制nginx连接的超时 主要是为了减少打开和关闭连接时的处理器和网络开销
...</p></div><footer class=entry-footer><span title='2022-03-20 00:00:00 +0000 UTC'>三月 20, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;iren.</footer><a class=entry-link aria-label="post link to Nginx简单的常规优化" href=https://blog.mletter.cn/tech/nginx/nginx-optimization/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.mletter.cn/page/4/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://blog.mletter.cn/page/6/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://blog.mletter.cn/>太阳可以是蓝色</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br><span id=span style=color:#101011></span>
<script type=text/javascript>function runtime(){const a=new Date("12/07/2020 12:50:18"),r=new Date,c=r.getTime()-a.getTime(),l=24*60*60*1e3,e=c/l,t=Math.floor(e),n=(e-t)*24,s=Math.floor(n),o=(n-s)*60,i=Math.floor(o),d=Math.floor((o-i)*60);document.getElementById("span").innerHTML="已运行: "+t+"天"+s+"小时"+i+"分"+d+"秒"}runtime(),setInterval(runtime,1e3)</script><br><font color=#101011>本站由 <a href=https://www.netlify.com/ rel="noopener noreferrer nofollow" target=_blank>Netlify</a> 提供计算服务, 由 <a href=https://www.netlify.com/ rel="noopener noreferrer nofollow" target=_blank>Netlify</a> 提供全站加速服务。</font><br></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>const menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=this.getAttribute("href").substr(1),n=document.querySelector(`[id='${decodeURIComponent(t)}']`);window.matchMedia("(prefers-reduced-motion: reduce)").matches?n.scrollIntoView():n.scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>const mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.classList.contains("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>